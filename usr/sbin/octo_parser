#!/usr/bin/perl -w
=head1 NAME

octo_parser - Octopussy Parser program

=head1 SYNOPSIS

octo_parser <device> 

=head1 DESCRIPTION

octo_parser is the program used by the Octopussy Project 
to parse Logs for each Device

=cut
use strict;
use bytes; # Fix the 'Malformed UTF-8 character' warning
use utf8;

use File::Basename;
use File::Copy;
use File::Path;
use Linux::Inotify2;
use AAT;
use Octopussy;

my $PROG_NAME = "octo_parser";
my $NICE_UPARSER = "nice -n 20";

my $dir_program = Octopussy::Directory("programs");
my $dir_pid = Octopussy::Directory("running");
my $device = $ARGV[0];
my ($reload_request, $exit_request) = (0, 0);
my $cache = Octopussy::Cache::Init("octo_parser");

my @services;
my (%alert, %service);
my (%taxo_stats, %msgid_stats);
my $minutes_without_logs;
my %dir_data = ();
my (@files, @taxo_list, %known_msgs, @unknown_msgs) = ((), (), (), ());
my ($file, $file_last) = (undef, undef);

my %parser_stats = ();
my ($year, $month, $day, $hour, $min) = (0, 0, 0, 0, 0);
my ($nb_lines_minute, $seconds_to_parse) = (0, 0);

my $file_pid = Octopussy::PID_File($PROG_NAME . "_$device")
  or die "$PROG_NAME: Parsing $device - Process already running !";

my $inotify = new Linux::Inotify2
	or die "$PROG_NAME: Unable to create new inotify object: $!";
$inotify->blocking(0);

=head1 FUNCTIONS

=head2 Exit()

Softly stops the parser 
(current file is fully parsed before exiting)

=cut
sub Exit
{
	$exit_request = 1;
}

=head2 Reload()

Softly reloads the configuration of the parser 
(current file is fully parsed before reload)

=cut
sub Reload
{
	$reload_request = 1;
}

=head2 Inotify_Watch($path)

Watches '$path' with inotify

=cut
sub Inotify_Watch
{
	my $filename = shift;

 	if (-d $filename)
  { 
		if ($filename =~ /\/Incoming\/+\d{4}\/+\d{2}\/+\d{2}/)
    	{ $inotify->watch($filename, IN_CLOSE_WRITE); }
  	else
    	{ $inotify->watch($filename, IN_CREATE); }
		opendir(DIR, $filename);
		my @content = grep !/^\./, readdir(DIR);
		foreach my $c (sort @content)
			{ Inotify_Watch("$filename/$c"); }
	}
  elsif (-f $filename)
  { 
		$filename =~ s/\/+/\//g;
		push(@files, $filename); 
	}
}

=head2 Init()

Inits Parser & launch UParser if needed

=cut
sub Init()
{
	my $dconf = Octopussy::Device::Configuration($device) or 
		die("[OCTOPUSSY ERROR: Unable to get Device configuration for '$device']");
	$minutes_without_logs = $dconf->{minutes_without_logs};
	@services = Octopussy::Device::Services($device);	
	@taxo_list = Octopussy::Taxonomy::List()
		or die("[OCTOPUSSY ERROR: Unable to get Taxonomy configuration]");
	$dir_data{"Unknown"} = Octopussy::Storage::Directory_Unknown($device); 
	foreach my $serv (@services)
 	{
		$dir_data{$serv} = Octopussy::Storage::Directory_Service($device, $serv);
		Octopussy::RRDTool::Syslog_By_Device_Service_Taxonomy_Init($device, $serv);
  	my @msg_to_parse = ();
   	my @messages = Octopussy::Service::Messages($serv);
		AAT::Syslog($PROG_NAME, "PARSER_INIT_SERVICE", $serv, scalar(@messages));
		my @dev_alerts = Octopussy::Alert::For_Device($device);
   
    my %contact = ();
    foreach my $c (Octopussy::Contact::Configurations("cid"))
      { $contact{$c->{cid}} = $c; }
   	foreach my $m (@messages)
    { 
			my @alerts = Octopussy::Message::Alerts($device, $serv, $m, \@dev_alerts, \%contact);
			my @msg_alerts = ();
			foreach my $a (@alerts)
			{
				$alert{$a->{name}} = $a;
				foreach my $act (@{$a->{action}})
				{ 
					$alert{$a->{name}}->{action_mail} = 1		if ($act =~ /Mail/i); 
					$alert{$a->{name}}->{action_jabber} = 1 if ($act =~ /Jabber/i);
					$alert{$a->{name}}->{action_nsca} = 1 	if ($act =~ /NSCA/i);
				}
				push(@msg_alerts, $a->{name});
			}
			my $regexp = Octopussy::Message::Pattern_To_Regexp($m);
      push(@{$service{$serv}{msgs}}, 
				{ re => qr/^$regexp\s*[^\t\n\r\f -~]?$/i, id => $m->{msg_id},
          pattern => ((scalar(@msg_alerts) > 0) ? $m->{pattern} : undef),
					taxo => $m->{taxonomy}, alerts => \@msg_alerts } ); 
		}
	}
  if (AAT::NOT_NULL($cache->get("uparser_$device")))
    { $cache->set("uparser_$device", "reload"); }
  else
    { system("$NICE_UPARSER ${dir_program}octo_uparser $device &"); }
	($file, $file_last) = (undef, undef);
	(@files, %known_msgs, @unknown_msgs) = ((), (), ());

	my $dir =  Octopussy::Storage::Directory_Incoming($device);
	Octopussy::Create_Directory("$dir/$device/Incoming/")	
		if (! -d "$dir/$device/Incoming/");
	Inotify_Watch("$dir/$device/Incoming/");
}

=head2 Write_Logfile($file, $logs)

Writes Known Logs '$logs' into Logfile '$file'

=cut
sub Write_Logfile($$)
{
	my ($logfile, $logs) = @_;

	if (scalar(@{$logs}) > 0)
	{
		$logfile =~ s/(msg_\d\dh\d\d)_\d+/$1/;
  	$logfile .= ".gz" if ($logfile !~ /^.+\.gz$/);
		Octopussy::Create_Directory(dirname($logfile));
   	if (defined open(FILE, "|gzip >> $logfile"))
		{
			foreach my $log (@{$logs})
   			{ print FILE "$log\n"; }
			close(FILE);
		}
		else
    {
    	print "Unable to open file '$logfile'\n";
     	AAT::Syslog("octo_parser", "UNABLE_OPEN_FILE", $logfile);
   	}
	}
}


=head2 Write_Unknown_Logfile($file, $logs)

Writes Unknown Logs '$logs' into Logfile '$file'

=cut
sub Write_Unknown_Logfile($$)
{
  my ($logfile, $logs) = @_;
	$logfile =~ s/^.+\/Incoming\//$dir_data{Unknown}\/$device\/Unknown\//;

	Write_Logfile($logfile, $logs);
}

=head2 Incoming_To_Unknown($incoming)

Moves Incoming file to Unknown file

=cut
sub Incoming_To_Unknown($)
{
	my $incoming = shift;
	my $unknown = $incoming;
  $unknown =~ s/^.+\/Incoming\//$dir_data{Unknown}\/$device\/Unknown\//;
	$unknown =~ s/(msg_\d\dh\d\d)_\d+/$1/;
	$unknown .= ".gz"	if ($unknown !~ /^.+\.gz$/);
	Octopussy::Create_Directory(dirname($unknown));

	if (defined open(FILE, "|gzip >> $unknown"))
  {
		my $cat = ($incoming =~ /.+\.gz$/ ? "zcat" : "cat");
		if (defined open(INCOMING, "$cat \"$incoming\" |"))
		{
			while (<INCOMING>)
      	{ print FILE $_; }
      close(INCOMING);
			unlink $incoming;
		}
		else
  	{
    	print "Unable to open file '$incoming'\n";
    	AAT::Syslog("octo_parser", "UNABLE_OPEN_FILE", $incoming);
  	}
  }
 	else
 	{
  	print "Unable to open file '$unknown'\n";
   	AAT::Syslog("octo_parser", "UNABLE_OPEN_FILE", $unknown);
 	}
}

=head2 Alert_Handler($msg, $line)

Handles Alert(s) for the Message $msg on line $line

=cut
sub Alert_Handler($$)
{
	my ($msg, $line) = @_;

	if ($line =~ /^(\w{3} \s?\d{1,2} \d\d:\d\d:\d\d) \S+/)
	{
  	my $date = $1;
		my $parse_date = Date::Manip::ParseDate($date);
   	my $date_tp = Date::Manip::UnixDate($parse_date, "%A %H:%M");
   	my $secs = Date::Manip::UnixDate($parse_date, "%s");
		foreach my $msg_alert (@{$msg->{alerts}})
  	{
			my $a = $alert{$msg_alert};
			if ((Octopussy::TimePeriod::Match($a->{timeperiod}, $date_tp))
				&& ((AAT::NULL($a->{regexp_incl}) || ($line =~ /$a->{regexp_incl}/)))
        && ((AAT::NULL($a->{regexp_excl}) || ($line !~ /$a->{regexp_excl}/))))
			{
				my $alert_logs = $cache->get($a->{name});
				if (defined $a->{thresold_time})
					{ push(@{$alert_logs}, { timestamp => $secs, log => $line }); }
				if ((!defined $a->{thresold_time}) 
					|| (scalar(@{$alert_logs}) >= $a->{thresold_time}))
				{
					my $match = 1;
					if (defined $a->{thresold_time})
					{
						while (($secs - ${$alert_logs}[0]->{timestamp})
										> $a->{thresold_duration})
						{
							shift @{$alert_logs};
							$match = 0;
						}
					}
					if ($match)
					{
						my $data = "";
						if (defined $a->{thresold_time})
						{
							foreach my $d (@{$alert_logs})
								{ $data .= "$d->{log}\n"; } 
						}
						else
							{ $data = $line; }
						$alert_logs = ();
						Octopussy::Alert::Insert_In_DB($device, $a, $data, $date);
						my ($subject, $body) = 
							Octopussy::Alert::Message_Building($a, $device, $data, $msg);
						if (defined $a->{action_jabber})
						{
							AAT::XMPP::Send_Message("Octopussy", $subject, @{$a->{imdest}});
							foreach my $line (split(/\n/, $body))
    					{ AAT::XMPP::Send_Message("Octopussy", $line, @{$a->{imdest}}); }
						}
						AAT::SMTP::Send_Message("Octopussy", $subject, $body, 
							@{$a->{maildest}}) if (defined $a->{action_mail});
						AAT::NSCA::Send("Octopussy", (($a->{level} =~ /Warning/i) ? 1 : 2),	
							$subject, $a->{nagios_host}, $a->{nagios_service}) 
              if (defined $a->{action_nsca}); 
					}
				}
				$cache->set($a->{name}, $alert_logs);
			}
		}
  }
}

=head2 Line_Handler($line, $serv, $msg, $known_msgs, $match)

Handles line $line for Service $serv & Message $msg

=cut
sub Line_Handler($$$$$)
{
	my ($line, $serv, $msg, $known_msgs, $match) = @_;
 
	if ($line =~ $msg->{re})
  {
  	Alert_Handler($msg, $line)  if (scalar(@{$msg->{alerts}}) > 0);
    push(@{$known_msgs->{$serv}}, $line);
		$taxo_stats{$serv}{$msg->{taxo}} = 
      (defined $taxo_stats{$serv}{$msg->{taxo}} 
      ? $taxo_stats{$serv}{$msg->{taxo}} + 1 : 1);

    $msgid_stats{$serv}{$msg->{id}} = 
      (defined $msgid_stats{$serv}{$msg->{id}} 
      ? $msgid_stats{$serv}{$msg->{id}} + 1 : 1);

		$$match = 1;
  }
	elsif ($line =~ /last message repeated \d+ time/)
  {
  	push(@{$known_msgs->{$serv}}, $line);
		$$match = 1;
	}
}

=head2 Service_Handler($serv, $y, $m, $d, $hour, $min, $file_new)

Handles Service $serv

=cut
sub Service_Handler($$$$$$$)
{
	my ($serv, $y, $m, $d, $hour, $min, $file_new) = @_;	

 	my $dir_service = $serv;
 	$dir_service =~ s/ /_/g;
 	my $dir = "$dir_data{$serv}/$device/$dir_service/$y/$m/$d/";
  Write_Logfile("$dir$file_new", \@{$known_msgs{$serv}});
  $parser_stats{$serv} += scalar(@{$known_msgs{$serv}});
}

=head2 Cache_MsgID_Stats()

Puts MsgID Statistics in cache

=cut
sub Cache_MsgID_Stats()
{
  my @parser_msgid_stats = ();
  foreach my $k1 (keys %msgid_stats)
  {
    foreach my $k2 (keys %{$msgid_stats{$k1}})
    {
      my $id = $1  if ($k2 =~ /^.+?:(.+)$/);
      my $count = $msgid_stats{$k1}{$k2};
      push(@parser_msgid_stats, 
        { service => $k1, id => $id, count => $count } )
        if ($count > 0);
      $msgid_stats{$k1}{$k2} = 0;
    }
  }
  $cache->set("parser_msgid_stats_$year$month$day$hour${min}_$device",
    \@parser_msgid_stats);
}

=head2 Cache_Taxonomy_Stats($service)

Puts Taxonomy Statistics in cache

=cut
sub Cache_Taxonomy_Stats($)
{
  my $service = shift;

  my @taxo_rrd = ();
  foreach my $t (@taxo_list)
  {
    push(@taxo_rrd, $taxo_stats{$service}{$t->{value}} || 0);
    $taxo_stats{$service}{$t->{value}} = 0;
  }
  my $seconds_to_parse
    = AAT::Datetime::Seconds_Since_1970($year, $month, $day, $hour, $min);
  $cache->set("parser_taxo_stats_${device}_${service}",
    { datetime => $seconds_to_parse, stats => \@taxo_rrd });
}

=head2 File_Handler($file)

Handles file $file

=cut
sub File_Handler($)
{
	my $file = shift;

	my $time = time();
	if ($file =~ /\/(\d+)\/(\d+)\/(\d+)\/(msg_(\d\d)h(\d\d)_\d+\.log)/)	
	{
		my ($n_year, $n_month, $n_day, $file_new, $n_hour, $n_min) = 
      ($1, $2, $3, $4, $5, $6);

		if ($year == 0)
		{
			($year, $month, $day, $hour, $min)
        = ($n_year, $n_month, $n_day, $n_hour, $n_min);
		}
    if (($n_min != $min) || ($n_hour != $hour) || ($n_day != $day)
        || ($n_month != $month)) 
    { # not the same minute than previous file -> write stats to syslog
      foreach my $s (@services)
      {
        if ((AAT::NOT_NULL($parser_stats{$s})) && ($parser_stats{$s} != 0))
        { 
          AAT::Syslog($PROG_NAME, "PARSER_DEVICE_SERVICE_EVENTS", $device, $s, 
            "$day/$month/$year $hour:$min", 
            $parser_stats{$s}, $nb_lines_minute);
          Cache_Taxonomy_Stats($s);
          $parser_stats{$s} = 0;
        }
      }
      Cache_MsgID_Stats();   
      AAT::Syslog($PROG_NAME, "PARSER_DEVICE_PARSING_DURATION",
        $device, "$day/$month/$year $hour:$min", $seconds_to_parse);
      ($nb_lines_minute, $seconds_to_parse) = (0, 0);
      ($year, $month, $day, $hour, $min) 
        = ($n_year, $n_month, $n_day, $n_hour, $n_min);
    }

    (%known_msgs, @unknown_msgs) = ((), ());
    my $cat = ($file =~ /.+\.gz$/ ? "zcat" : "cat");
		if ((-f "$file") && (defined open(FILE, "$cat \"$file\" |")))
		{
			while (<FILE>)
 			{
  			my $line = $_;
   			chomp($line);
				my $match = 0;
    		foreach my $serv (@services)
    		{
   				foreach my $msg (@{$service{$serv}{msgs}})
      		{ 
						Line_Handler($line, $serv, $msg, \%known_msgs, \$match); 
						last if ($match);
					}
					last if ($match);
				}
				push(@unknown_msgs, $line)	if (! $match);
				$nb_lines_minute++;
			}
			close(FILE);
			unlink $file;	
		}
		else
    {
    	print "Unable to open file '$file'\n";
     	AAT::Syslog("octo_parser", "UNABLE_OPEN_FILE", $file);
    }
		foreach my $serv (keys %known_msgs)
	  {	
      Service_Handler($serv, $n_year, $n_month, $n_day, 
        $n_hour, $n_min, $file_new); 
    }
		Write_Unknown_Logfile($file, \@unknown_msgs);
    $seconds_to_parse += (time() - $time);
	}
}

#
# MAIN
#
if (!Octopussy::Valid_User())
{
  print "You need to be Octopussy user to use $PROG_NAME !\n";
  exit;
}

$SIG{HUP} = \&Reload;
$SIG{USR1} = \&Exit;

AAT::Syslog($PROG_NAME, "PARSER_START", $device);
Init();
AAT::Syslog($PROG_NAME, "PARSER_FILES_TO_PARSE", $device, scalar(@files));
my $last_logs_time = time();
while (!$exit_request)
{
	my @events = $inotify->read;
  foreach my $e (@events)
  	{ Inotify_Watch($e->fullname); }
	if (scalar(@files) > 0)
 		{ $last_logs_time = time(); }
  else
  {
    my $diff = time() - $last_logs_time;
    if ((AAT::NOT_NULL($minutes_without_logs))
      && ($diff > ($minutes_without_logs*60)))
    {
      AAT::Syslog($PROG_NAME, "DEVICE_HASNT_SENT_ANY_LOGS",
        $device, int($diff/60));
    }
  }
	while ($file = shift(@files))
  {
    chomp($file);
    if (scalar(@services) == 0)
      { Incoming_To_Unknown($file); }
    else
      { File_Handler($file); }
    last  if ($reload_request || $exit_request);
  }
  if ($reload_request)
  {
    $reload_request = 0;
    Init();
  }

	if (!$exit_request)
		{ sleep(2); }
}
AAT::Syslog($PROG_NAME, "PARSER_STOP", $device);

=head1 AUTHOR

Sebastien Thebert <octo.devel@gmail.com>

=head1 SEE ALSO

octo_dispatcher, octo_extractor, octo_uparser, octo_reporter, octo_scheduler

=cut
